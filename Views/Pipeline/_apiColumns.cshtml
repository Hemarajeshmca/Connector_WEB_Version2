@model Connection
@{

}
<style>
    #ApiKeyGrid .k-icon.k-i-expand,
    #ApiKeyGrid .k-icon.k-i-collapse {
        background-image: url('/Content/kendo1/2015.1.318/Default/sprite.png') !important;
        background-repeat: no-repeat;
    }

</style>
<div class="modal" tabindex="-1" role="dialog" id="apiColumn_Popup" aria-hidden="true">
    <div class="modal-dialog modal-md" role="dialog">
        <div class="modal-content" style="width: 75%;left: 0%;box-shadow:0 0 8px 8px rgba(153, 153, 153, 0.8) !important">
            <div class="modal-body" style="margin-top: -15%;margin-left: 3%;margin-right: 3%;">
                <div class="row">
                    <h4 style="font-size: 15px;text-align: center;color: #1a9950;font-weight: 600;">API Column</h4>
                </div>
                <div class="row">
                    <label class="form-label">Serial No</label>
                    <input class="form-control" type="text" id="txt_pplapifield_gid" name="txt_pplapifield_gid" style="display:none" />
                    <input class="form-control" type="number" id="txt_apiserialno" name="txt_serialno" min="1" oninput="validateNumberInput(this,'serialno')" />
                </div>
                <div class="row">
                    <label class="form-label">Column Name </label>
                    <input class="form-control" type="text" id="txt_apicolumnname" name="txt_columnname" />
                </div>
                <div class="row">
                    <label class="form-label">Data Type</label>
                    @* <input class="form-control" type="text" id="txt_csvcol_datatype" name="txt_csvcol_datatype" /> *@
                    <select class="form-control" id="drp_apicol_datatype" name="drp_apicol_datatype" style="width:100%;height:25%">
                        <option value="-- Select --">-- Select --</option>
                        <option value="TEXT">TEXT</option>
                        <option value="INTEGER">INTEGER</option>
                        <option value="DATE">DATE</option>
                        <option value="DATETIME">DATETIME</option>
                        <option value="NUMERIC">NUMERIC</option>
                    </select>
                </div>
                <div class="row">
                    <div class="col-sm-3">
                    </div>
                    <div class="col-sm-3"> </div>
                    <div class="col-sm-6" style="margin-top: 2%;text-align: right; display:flex;">
						<input style="float: right;margin-top: 0%;" type="button" id="api_cancel" onclick="CloseApiColumns()" class="cancel action-button-previous" value="Cancel" />
                        <input style="float: right;margin-right: 0%;" type="button" id='btn_saveApiColumns' onclick="saveApiColumns()" class="save" value="Save" />
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="modal" tabindex="-1" role="dialog" id="apiDatastruture_Popup" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="dialog">
        <div class="modal-content" style="width: 75%;left: 0%;box-shadow:0 0 8px 8px rgba(153, 153, 153, 0.8) !important">
            <div class="modal-body" style="margin-top: -15%;margin-left: 3%;margin-right: 3%;">
                <div class="row">
                    <h4 style="font-size: 15px;text-align: center;color: #1a9950;font-weight: 600;">API Data Structure</h4>
                </div>
              
                <div class="row">
                    <div id="srcapiDataStructure_old" style="margin-top: -3%;"></div>
                </div>
              
                <div class="row">
                    <div class="col-sm-3">
                    </div>
                    <div class="col-sm-3"> </div>
                    <div class="col-sm-6" style="margin-top: 2%;text-align: right; display:flex;">
                        <input style="float: right;margin-top: 0%;" type="button" id="api_validate" onclick="validateApiDataStructure('Yes')" class="save query_clr" value="Validate" />
                        <input style="float: right;margin-top: 0%;" type="button" id="api_cancel" onclick="CloseApiColumns()" class="cancel action-button-previous" value="Cancel" />
                        <input style="float: right;margin-right: 0%;" type="button" id='btn_saveApiDatastrucre' onclick="saveApiDatastrucre()" class="save" value="Save" />
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="datafieldselection" style="padding-left: 15px; display:none;">
   @*  <div class="row">
        <div class="col-sm-3">
        </div>
        <div class="col-sm-3"> </div>
        <div class="col-sm-6" style="margin-top: 2%;text-align: right; display:flex;">
            <input style="float: right;margin-top: 0%;" type="button" id="api_validate" onclick="validateApiDataStructure()" class="save query_clr" value="Validate & Save" />
            <input style="float: right;margin-top: 0%;" type="button" id="api_cancel" onclick="CloseApiColumns()" class="cancel action-button-previous" value="Cancel" />
            <input style="float: right;margin-right: 0%;" type="button" id='btn_saveApiDatastrucre' onclick="saveApiDatastrucre()" class="save" value="Save" />
        </div>
    </div> *@

    <div class="row" style="margin-top: -57px;margin-bottom: 33px;">
        <div class="col-sm-4">
        </div>
        <div class="col-sm-4">
        </div>
        <div class="col-sm-4" id="btn_save" style="margin-left: 77%; display: flex;top: 6px;">
            <input style="padding: 1rem !important;cursor:pointer;width: 29%;" type="button" onclick="validateApiDataStructure('Yes')" id='api_validate' class="save" value="Validate & Save" />
            <input style="padding: 1rem !important;cursor:pointer;margin-left: 12px; color: red;background-color: white;border: 1px solid red;" type="button" onclick="revertChanges()" id='btn_fieldSelectionRevert' class="save" value="Revert" />
        </div>
    </div>

    
    <div class="row">
        <div id="srcapiDataStructure" style="margin-top: -3%;"></div>
    </div>
 
</div>

<script>
    function CloseApiColumns() {
        $("#apiColumn_Popup").hide();
        $("#apiDatastruture_Popup").hide();
    }

      function loadapiDatastrutureGrid() {
        var jsonInput = datasetfiledname;
        let jsonObj = typeof jsonInput === "string" ? JSON.parse(jsonInput) : jsonInput;
        let treeData = [];
        let nodeId = 1;

        function buildTreeRows(token, parentId, parentKey) {
            if (Array.isArray(token)) {
                if (token.length > 0) {
                    buildTreeRows(token[0], parentId, parentKey);
                }
            } else if (typeof token === "object" && token !== null) {
                Object.keys(token).forEach(function (key) {
                    let value = token[key];
                    let currentId = nodeId++;
                    let isArray = Array.isArray(value);

                    treeData.push({
                        id: currentId,
                        parentId: parentId,
                        name: key,
                        keyNode: key,
                        parentKey: parentKey,
                        valueType: isArray ? "Multiple" : "Single",
                        level: parentId == null ? 0 : getLevelFromParent(treeData, parentId) + 1,
                        selected: false
                    });
                    buildTreeRows(value, currentId, key);
                });
            }
        }

        function getLevelFromParent(data, parentId) {
            const parent = data.find(x => x.id === parentId);
            return parent ? parent.level : 0;
        }

        // Start recursive conversion
        buildTreeRows(jsonObj, null, "");

        const sourceFieldNames_n = sourceFieldNames.map(x => x.sourcefield_name);
        treeData.forEach(item => {
            item.selected = sourceFieldNames_n.includes(item.keyNode);
        });

        // Destroy existing grid (if any)
        if ($("#ApiKeyGrid").data("kendoTreeList")) {
            $("#ApiKeyGrid").data("kendoTreeList").destroy();
            $("#ApiKeyGrid").remove();
        }
        // Add container
        $("#srcapiDataStructure").append(
            '<div id="ApiKeyGrid" style="width:96%; height:310px; margin-top:15px;"></div>'
        );

        // Initialize Kendo TreeList
        $("#ApiKeyGrid").kendoTreeList({
            dataSource: {
                data: treeData,
                schema: {
                    model: {
                        id: "id",
                        parentId: "parentId",
                        fields: {
                            id: { type: "number" },
                            parentId: { type: "number", nullable: true },
                            name: { type: "string" },
                            keyNode: { type: "string" },
                            parentKey: { type: "string" },
                            valueType: { type: "string" },
                            level: { type: "number" },
                            selected: { type: "boolean" }
                        },
                        expanded: true
                    }
                }
            },
            height: 310,
            selectable: true,
            editable: true,
            columns: [
                {
                    field: "name",
                    title: "JSON Data Structure",
                    expandable: true,
                    width: 350,
                    template: function (item) {
                        return `<span>${item.name}</span>`;
                    }
                },
                {
                    field: "selected",
                    title: "Select",
                    width: 80,
                    attributes: { style: "text-align: center;" },
                    template:
                        '<input type="checkbox" class="nodeSelect" #= selected ? "checked" : "" # />',                    
                },
                {
                    field: "valueType",
                    title: "Value Type",
                    width: 150,
                    editor: valueTypeEditor,                    
                },
                { field: "level", title: "Level", hidden: true },
                { field: "parentKey", title: "Parent Node", hidden: true },
                { field: "keyNode", title: "Key Node", hidden: true }
            ],
            dataBound: onTreeListDataBound
        });

        function onTreeListDataBound(e) {
            var treeList = this;            
            treeList.tbody.find(".nodeSelect").off("change").on("change", function () {
                var tr = $(this).closest("tr");
                var dataItem = treeList.dataItem(tr);
                var checked = $(this).is(":checked");
                dataItem.set("selected", checked); 
            });
        }

        function valueTypeEditor(container, options) {
            $('<input required name="' + options.field + '"/>')
                .appendTo(container)
                .kendoDropDownList({
                    dataSource: ["Select", "Single", "Multiple"]
                });
        }
    }

    let persistedSelectedKeys = [];
    function validateApiDataStructure(type) {
        const treeList = $("#ApiKeyGrid").data("kendoTreeList");
        if (!treeList) {
            jAlert("No data found", "Connector");            
            return;
        }

        const allData = treeList.dataSource.data().slice(); // flat list
        if (!allData || allData.length === 0) {
            jAlert("No data available in the tree.", "Connector");
            return;
        }
        buildKeyPaths(allData);
        const dt = allData
            .filter(item => item.selected)
            .map(item => ({
                node: item.keyNode,
                level: item.level,
                parent_node: item.parentKey
            }));
        if (dt.length === 0) {
            jAlert("Please select at least one key field to validate.", "Connector");
            return;
        }

        if (!validateSelectionRules(allData)) {            
            return;
        }

        const selectedKeys = allData
            .filter(item => isNodeSelectedOrChildSelected(item, allData))
            .map(item => item.keyPath || item.keyNode);

        if (selectedKeys.length === 0) {
            jAlert("Please select at least one key field to validate.", "Connector");
            return;
        }

        const dtNode = buildDtNodeFromDt(dt);
        $("#txtSelectedKeys").val(selectedKeys.join("\n"));
        const nodeList = BuildNodesFromSelectedKeys(selectedKeys); 
        BindNodeGrid(nodeList); 
        Jsonreader(); 
        try {
            const extractJson = $("#txtExtractJson").val();
            const table = JsonToDataTableFullyDynamic("[" + extractJson + "]");
            $("#dgvExtractedJson").data("kendoGrid")?.dataSource.data(table);
        } catch (ex) {           
           // console.warn("Could not build extracted table:", ex);
        }
       
        apiResponseStructure = getApiKeyStructure();
        if (type == 'Yes'){
            saveapisrcfields("Yes");
        } else {
            getdatasetfield();
        }
        

       //  jAlert("Validation Successful!\n\nSelected Keys:\n" +
       //      selectedKeys.map(k => " - " + k).join("\n"), "Connector");                   
       // if (selectedKeys && selectedKeys.length > 0) {
       //      var structure = {};
       //      selectedKeys.forEach(k => {
       //          structure[k] = "";
       //  });
       //  }
       //  var ds_name1 = "Connector";
       //  apiResponseStructure[ds_name1] = structure;
       //   saveapisrcfields("Yes");
          persistedSelectedKeys = selectedKeys.slice();
          $("#tab4").removeClass("show-tab-important");
          $("#tab3").addClass("show-tab-important");
          const apiFieldTab = document.getElementById("apiDSSelectionTab");
          const validationTab = document.getElementById("validationTab");
          const fieldmappingTab = document.getElementById("fieldmappingTab");
          const filtersTab = document.getElementById("filtersTab");
          const expressionConf = document.getElementById("expression_conf");
          const fieldmappingConf = document.getElementById("fieldmapping_conf");
          const apiDSSelection_conf = document.getElementById("apiDSSelection_conf");
          const datafieldselection = document.getElementById("datafieldselection");
            fieldmappingConf.style.display = "block";
            filtersConf.style.display = "none";
            apiFieldTab.classList.remove("active")
            fieldmappingTab.classList.add("active");
            filtersTab.classList.remove("active");
            apiDSSelection_conf.style.display = "none";
            datafieldselection.style.display = "none";
    }

    function buildKeyPaths(allData) {
        const map = new Map();
        allData.forEach(d => map.set(d.keyNode, d));

        for (const node of allData) {
            if (node.keyPath) continue; 
            let parts = [];
            let current = node;
            const visited = new Set();
            while (current && !visited.has(current.keyNode)) {
                visited.add(current.keyNode);
                parts.unshift(current.keyNode);
                if (!current.parentKey) break;
                current = map.get(current.parentKey);
            }
            node.keyPath = parts.join(".");
        }
    }

    function buildDtNodeFromDt(dt) {
        if (!dt || dt.length === 0) return [];

        const maxLevel = Math.max(...dt.map(d => d.level));
        let keyLevel = maxLevel;
        let parentKey = "";
        let parentKey1 = "";
        let childKey = "";
        const result = [];

        do {
            let siblingKey = "";
            const filtered = dt.filter(d => {
                if (keyLevel === maxLevel) return d.level === keyLevel;
                return d.level === keyLevel && d.node === parentKey;
            });

            let i = 0;
            parentKey1 = parentKey;
            let data_row1 = null;

            filtered.forEach(row => {
                if (i === 0) {
                    data_row1 = {
                        node: row.node,
                        parent_node: row.parent_node,
                        level: keyLevel,
                        child_node: childKey,
                        sibling: ""
                    };
                    childKey = row.node;
                }
                parentKey = row.parent_node;
                if (i !== 0) siblingKey += row.node + ",";
                i++;
            });

            const others = dt.filter(d => {
                if (keyLevel === maxLevel) return d.level === keyLevel && d.parent_node !== parentKey;
                return d.level === keyLevel && d.node !== parentKey1;
            });
            others.forEach(r => siblingKey += r.node + ",");

            if (data_row1) {
                data_row1.sibling = siblingKey.replace(/,$/, "");
                result.push(data_row1);
            }

            keyLevel--;
        } while (keyLevel >= 0);
        result.sort((a, b) => a.level - b.level);
        return result;
    }

    function validateSelectionRules(allData) {
        const parentChildSelection = {};
        // Step 1: build parentChildSelection
        for (const item of allData) {
            const isChecked = isNodeSelectedOrChildSelected(item, allData);
            const tagPath = item.keyPath; 
            if (isChecked && tagPath) {
                const hasChildren = rowHasChildren(item, allData);
                const parentPath = getParentPath(tagPath);
                const childSelected = hasAnyChildSelected(item, allData);

                if (hasChildren && childSelected) {
                    if (!parentChildSelection[parentPath]) parentChildSelection[parentPath] = [];
                    parentChildSelection[parentPath].push(tagPath);
                }
            }
        }

        for (const parentPath in parentChildSelection) {
            const arr = parentChildSelection[parentPath];
            if (arr.length > 1) {
                let message = `You have selected multiple nodes with children under '${parentPath}':\n\n`;
                arr.forEach(tagPath => {
                    const childKeys = getChildKeys(tagPath, allData);
                    message += `• ${tagPath}`;
                    if (childKeys.length > 0) message += `   ↳ Child Keys: ${childKeys.join(", ")}`;
                    message += "\n";
                });
                $("#txtExtractJson").val("");
                const grid = $("#dgvExtractedJson").data("kendoGrid");
                if (grid) grid.dataSource.data([]);
                jAlert(message, "Validation Error");
                highlightInvalidNodes(arr);
                $("#txtSelectedKeys").val("");
                return false;
            }
        }
        persistedSelectedKeys = [];
        for (const item of allData) {
            if (isNodeSelectedOrChildSelected(item, allData)) {
                if (item.keyPath) persistedSelectedKeys.push(item.keyPath);
            }
        }
        return true;
    }

    function isNodeSelectedOrChildSelected(item, allData) {
        if (!item) return false;
        const stack = [item];
        const visited = new Set();
        while (stack.length) {
            const current = stack.pop();
            if (!current) continue;
            if (visited.has(current.keyNode)) continue;
            visited.add(current.keyNode);
            if (current.selected) return true;
            for (const child of allData) {
                if (child.parentKey === current.keyNode) stack.push(child);
            }
        }
        return false;
    }

    function rowHasChildren(item, allData) {
        if (!item) return false;
        return allData.some(d => d.parentKey === item.keyNode);
    }

    function hasAnyChildSelected(item, allData) {
        if (!item) return false;
        const stack = [];
        for (const d of allData) if (d.parentKey === item.keyNode) stack.push(d);
        const visited = new Set();
        while (stack.length) {
            const cur = stack.pop();
            if (!cur || visited.has(cur.keyNode)) continue;
            visited.add(cur.keyNode);
            if (cur.selected) return true;
            for (const child of allData) if (child.parentKey === cur.keyNode) stack.push(child);
        }
        return false;
    }

    function getParentPath(tagPath) {
        if (!tagPath) return "";
        // find last '.' or '['
        const lastDot = tagPath.lastIndexOf(".");
        const lastBracket = tagPath.lastIndexOf("[");
        const idx = Math.max(lastDot, lastBracket);
        if (idx >= 0) return tagPath.substring(0, idx);
        return "";
    }

    function getChildKeys(parentTagPath, allData) {
        if (!parentTagPath) return [];
        const result = new Set();
        for (const row of allData) {
            if (!row.keyPath) continue;
            if (row.keyPath.startsWith(parentTagPath + ".")) {
                if (isNodeSelectedOrChildSelected(row, allData)) {
                    const parts = row.keyPath.split(".");
                    const last = parts[parts.length - 1];
                    result.add(last);
                }
            }
        }
        return Array.from(result);
    }

    function highlightInvalidNodes(invalidPaths) {
        const treeList = $("#ApiKeyGrid").data("kendoTreeList");
        if (!treeList) return;
        const ds = treeList.dataSource.data();
        treeList.content.find("tr").css("background-color", "");
        for (const p of invalidPaths) {
            const item = ds.find(d => d.keyPath === p);
            if (item) {
                const row = treeList.content.find(`tr[data-uid='${item.uid}']`);
                row.css("background-color", "LightCoral");
            }
        }
    }

    function BuildNodesFromSelectedKeys(selectedKeys, allData) {
        const nodeMap = new Map();
        selectedKeys.forEach(keyPath => {
            const parts = keyPath.split("."); // Split hierarchical path
            let pathSoFar = "";
            let parentObj = null;

            parts.forEach((part, idx) => {
                pathSoFar = pathSoFar ? pathSoFar + "." + part : part;
                if (!nodeMap.has(pathSoFar)) {
                    const node = {
                        keyNode: part,
                        keyPath: pathSoFar,
                        children: []
                    };
                    nodeMap.set(pathSoFar, node);
                    if (parentObj) {
                        parentObj.children.push(node);
                    }
                }
                parentObj = nodeMap.get(pathSoFar);
            });
        });
        const topLevelNodes = [];
        nodeMap.forEach(node => {
            if (!node.keyPath.includes(".")) {
                topLevelNodes.push(node);
            }
        });
        return topLevelNodes;
    }

    function BindNodeGrid(nodeList, gridSelector = "#dgvSelectedKeys") {
        const flattened = [];
        function flatten(node, level = 0, parentKey = "") {
            flattened.push({
                node: node.keyNode,
                keyPath: node.keyPath,
                parent_node: parentKey,
                level: level,
                childrenCount: node.children.length,
                sibling: "" // optional, fill later if needed
            });
            node.children.forEach(child => flatten(child, level + 1, node.keyNode));
        }
        nodeList.forEach(n => flatten(n));
        const grid = $(gridSelector).data("kendoGrid");
        if (grid) {
            grid.dataSource.data(flattened);
        } else {
            $(gridSelector).kendoGrid({
                dataSource: {
                    data: flattened,
                    pageSize: 50
                },
                sortable: true,
                pageable: true,
                columns: [
                    { field: "node", title: "Node" },
                    { field: "keyPath", title: "Key Path" },
                    { field: "parent_node", title: "Parent Node" },
                    { field: "level", title: "Level" },
                    { field: "childrenCount", title: "Children Count" }
                ]
            });
        }
    }

    function Jsonreader(jsonSelector = "#txtExtractJson", gridSelector = "#dgvExtractedJson") {
        const jsonText = $(jsonSelector).val();
        if (!jsonText) {
            $(gridSelector).data("kendoGrid")?.dataSource.data([]);
            return;
        }
        let jsonData;
        try {
            jsonData = JSON.parse(jsonText);
            if (!Array.isArray(jsonData)) {
                jsonData = [jsonData];
            }
        } catch (err) {
            jAlert("Invalid JSON format: " + err.message, "JSON Parse Error");
            $(gridSelector).data("kendoGrid")?.dataSource.data([]);
            return;
        }

        const grid = $(gridSelector).data("kendoGrid");
        if (grid) {
            grid.dataSource.data(jsonData);
        } else {
            $(gridSelector).kendoGrid({
                dataSource: {
                    data: jsonData,
                    pageSize: 50
                },
                sortable: true,
                pageable: true,
                columns: Object.keys(jsonData[0] || {}).map(k => ({
                    field: k,
                    title: k
                }))
            });
        }
    }

        function getApiKeyStructure() {
        try {
            const treeList = $("#ApiKeyGrid").data("kendoTreeList");
            if (!treeList) {
                jAlert("No data found", "Connector");
                return null;
            }

            const allData = treeList.dataSource.data().slice(); // flat list of all nodes
            if (!allData || allData.length === 0) {
                jAlert("No data available in the tree.", "Connector");
                return null;
            }

            // optional: custom helper you mentioned
            buildKeyPaths(allData);

            // filter selected items only
            const selectedItems = allData.filter(item => item.selected);

            if (selectedItems.length === 0) {
                jAlert("No keys selected.", "Connector");
                return null;
            }

            // extract keys (you can adjust based on your schema)
            const selectedKeys = selectedItems.map(item => item.keyNode || item.key || item.fieldName);

            // build JSON structure
            const structure = {};
            selectedKeys.forEach(k => {
                if (k) structure[k] = "";
            });

            return structure; // ✅ returns JSON object of selected keys

        } catch (e) {
            console.error("Error reading TreeList:", e);
            jAlert("Error reading TreeList: " + e.message, "Error");
            return null;
        }
    }



</script>